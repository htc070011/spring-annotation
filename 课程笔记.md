### JUnit quick-start

- 在pom文件中导入junit相关依赖
- 使用@Test注解修饰待测试方法
- 可以使用@Before注解修饰每次测试都要执行的方法

### spring注解驱动开发

#### @Configuration与@Bean注解

+ 首先在pom文件中导入spring-context相关依赖
+ 创建配置类MainConfig，并用@Configuration标签进行标记
+ 在配置类中，通过给方法添加@Bean注解的方式声明注册bean，bean的class为返回值类型，bean的id默认为方法名，可以通过@Bean的value属性指定id

#### @ComponentScan注解自动扫描

1. @ComponentScan自动扫描

+ 使用@ComponentScan标记配置类，通过该注解的value属性指定包名

 - 使用@Controller，@Service，@Repository注解标记相应类

2. 指定扫描规则

ComponentScan的excludeFilters属性指定不进行扫描的类，includeFilters属性指定只进行扫描的类（使用时需要将@ComponentScan的default属性置为false），上述两个属性的为@Filters注解数组

- 通过@Filters注解的type属性配置过滤方式
- 通过@Filters注解的classes属性配置实现过滤方式的类

3. @ComponentScans注解为@ComponentScan注解的数组

#### 自定义@Filter规则

通过@Filters的FilterType属性配置过滤方式

1. ASSIGNABLE_TYPE：直接指定相应class
2. CUSTOM: 自定义过滤方式

+ 需要实现TypeFilter接口，实现其match(MetaDataReader metaDataReader, MetaDataReaderFacotry)方法。其中MetaDataReader对象包含扫描类的基本信息（修饰注解，类名等），MetaDataReaderFacotry对象包含其他所有类的基本信息

#### 组件作用域

组件作用域包含singleton，prototype，request（表示在同一个request中只创建一个bean）和session（表示在同一个session中只创建一个bean），通过@Scope注解进行配置。

+ singleton作用域修饰的bean对象在整个容器中只有一个，默认随容器的创建而加载，可以通过@Lazy注解将其配置为在第一次调用getBean（）方法时加载
+ prototype作用域修饰的bean在容器中存在多个对象，且默认为懒加载

#### @Conditional注解

@Conditional注解可以对Config类中的bean进行有条件的加载，该注解需要实现Condition接口中的matches方法，该方法传入两个参数

+ ConditionContext对象可以用来获取beanFactory，BeanDefinitionRegistry（bean定义的注册类），classloader，environment（当前环境，该环境可以用来获得虚拟机操作系统）
+ AnnotatedTypeMetadata对象可以获得修饰该配置类的注解
+ @Conditional注解也可以修饰类，当满足条件时注册该配置类下的所有用@Bean修饰的bean


#### 注册组件的常用方式

1. 通过@Bean注解------>适用于注册第三方包实现的类
2. 通过@ComponentScan+组件注解的方式----->适用于注册自己实现的类
3. 通过@Import注解快速导入，value属性为class类型，id默认为全类名
   + @Import注解中value属性也可以是实现了ImportSelector接口的class类型，实现selectImports(AnnotationMetdata annotationMetadata)方法，其中AnnotationMetdata对象可以获得修饰该配置类的其他注解信息
   + @Import注解中value属性也可以是























