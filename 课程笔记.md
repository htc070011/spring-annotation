### JUnit quick-start

- 在pom文件中导入junit相关依赖
- 使用@Test注解修饰待测试方法
- 可以使用@Before注解修饰每次测试都要执行的方法

### spring注解驱动开发

#### @Configuration与@Bean注解

+ 首先在pom文件中导入spring-context相关依赖
+ 创建配置类MainConfig，并用@Configuration标签进行标记
+ 在配置类中，通过给方法添加@Bean注解的方式声明注册bean，bean的class为返回值类型，bean的id默认为方法名，可以通过@Bean的value属性指定id

#### @ComponentScan注解自动扫描

1. @ComponentScan自动扫描

+ 使用@ComponentScan标记配置类，通过该注解的value属性指定包名

 - 使用@Controller，@Service，@Repository注解标记相应类

2. 指定扫描规则

ComponentScan的excludeFilters属性指定不进行扫描的类，includeFilters属性指定只进行扫描的类（使用时需要将@ComponentScan的default属性置为false），上述两个属性的为@Filters注解数组

- 通过@Filters注解的type属性配置过滤方式
- 通过@Filters注解的classes属性配置实现过滤方式的类

3. @ComponentScans注解为@ComponentScan注解的数组

#### 自定义@Filter规则

通过@Filters的FilterType属性配置过滤方式

1. ASSIGNABLE_TYPE：直接指定相应class
2. CUSTOM: 自定义过滤方式

+ 需要实现TypeFilter接口，实现其```boolean match(MetaDataReader metaDataReader, MetaDataReaderFacotry)```方法。其中MetaDataReader对象包含扫描类的基本信息（修饰注解，类名等），MetaDataReaderFacotry对象包含其他所有类的基本信息

#### 组件作用域

组件作用域包含singleton，prototype，request（表示在同一个request中只创建一个bean）和session（表示在同一个session中只创建一个bean），通过@Scope注解进行配置。

+ singleton作用域修饰的bean对象在整个容器中只有一个，默认随容器的创建而加载，可以通过@Lazy注解将其配置为在第一次调用getBean（）方法时加载
+ prototype作用域修饰的bean在容器中存在多个对象，且默认为懒加载

#### @Conditional注解

@Conditional注解可以对Config类中的bean进行有条件的加载，该注解需要实现Condition接口中的matches方法，该方法传入两个参数

+ ConditionContext对象可以用来获取beanFactory，BeanDefinitionRegistry（bean定义的注册类），classloader，environment（当前环境，该环境可以用来获得虚拟机操作系统）
+ AnnotatedTypeMetadata对象可以获得修饰该配置类的注解
+ @Conditional注解也可以修饰类，当满足条件时注册该配置类下的所有用@Bean修饰的bean


#### 注册组件的常用方式

1. 通过@Bean注解------>适用于注册第三方包实现的类

2. 通过@ComponentScan+组件注解的方式----->适用于注册自己实现的类

3. 通过@Import注解快速导入，value属性为class类型，id默认为全类名
   + @Import注解中value属性也可以是实现了ImportSelector接口的class类型，实现```String[] selectImports(AnnotationMetdata annotationMetadata)```方法，该方法以字符串的形式直接返回需要注册的组件的全限定名，其中AnnotationMetdata对象可以获得修饰该配置类的其他注解信息

   + @Import注解中value属性也可以是实现ImportBeanDefinitionRegistrar接口的类，需要实现接口

     ```void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)```

     其中AnnotationMetadata 可以获得修饰该类的其他注解信息，可以通过BeanDefinitionRegistry 的registerBeanDefinition方法手动注册bean，该方法需要传入bean的id以及bean的定义信息，定义信息由实现了BeanDefinition接口的对象进行封装，可以指定类名，Scope等属性。

4. 通过实现FactoryBean接口进行注册

  + 实现FactoryBean的三个接口```T getObject()```,```Class<?> getObjectType()```,```boolean isSingleton()```。
  + 通过@Bean的方式注册工厂Bean，通过applicationContext.getBean("bean id")方法将得到getObject()返回的对象类型
  + 如果想在容器中注册工厂Bean，需要在getBean("bean id")时在id名前加上"&"。

#### Bean生命周期

1. 定义初始化和销毁逻辑
  + 在定义bean时指定init()方法与destory()方法
      + 通过在@Bean注解中指定initMethod与destoryMethod属性。
      + 对于singleton的bean，init()方法在对象创建完成并赋值被调用，destory()方法在容器关闭时被调用
      + 对于prototype的bean，init()方法在getBean()完成对象创建和赋值后被调用，容器不对destory()进行管理
  + 通过实现spring提供接口的方式实现初始化和销毁逻辑
      + 让bean实现```InitializingBean```的接口方法
      ```void afterPropertiesSet()```
      定义bean的初始化逻辑，该方法在bean的属性赋值完成后执行
      + 通过让bean实现```DisposableBean```的接口方法
      ```void destroy()```
      定义bean的销毁逻辑，该方法在容器关闭时调用
  + 通过JSR250提供的注解修饰bean中实现逻辑的方法
      + 通过@PostConstruct注解修饰初始化逻辑方法，该方法在bean构造与赋值完成后执行
      + 通过@PreDestory注解修饰销毁逻辑方法，该方法在容器移除bean时被调用

2. 在初始化方法前后处理bean
  这里的初始化方法是指上述实现初始化逻辑的方法,例如被@PostConstruct修饰，实现afterPropertiesSet()，bean中的init()方法
  + 通过实现BeanPostProcessor
  ```public Object postProcessBeforeInitialization(Object o, String s)```
  该接口用来实现在初始化方法前需要处理的逻辑，Object o是创建并完成赋值后的对象，s为该对象在容器中的名字，返回值为经过处理的对象
  + 通过实现
  ```public Object postProcessAfterInitialization(Object o, String s) ```
  该接口用来实现在初始化方法后需要处理的逻辑，该方法在初始化方法结束后调用

3. Bean生命周期简要总结
  主要执行流程如下：

  ```java
  a. populateBean()//对象属性赋值
  
  b. initializeBean()//执行初始化逻辑
  
  c. applyBeanPostProcessorsBeforeInitialization()
  
  d. invokeInitMethods()
  
  e. applyBeanPostProcessorsAfterInitialization()
  ```

4. BeanPostProcessor在spring中的应用

	+ AplicationContextAware
	+ BeanValidate
	+ @PostConstructor
	+ @Autowired

####Bean属性赋值
1. @Value

2. \#{}

3. ${}在环境变量里面的值

	+ .properties
	+ 配置类中@PropertySource 保存在环境变量中，可以通过enviroment的getProperty获取配置文件中的
	+ @PropertySources可以指定多个@PropertySource































